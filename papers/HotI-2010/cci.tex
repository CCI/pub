\documentclass[conference]{IEEEtran}

\usepackage{cite}

\usepackage{url}

\usepackage{color}
\usepackage{xcolor}

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor Myri-com Myrinet-Express Path-Scale}

\begin{document}
%
\title{CCI: Common Communication Interface}
% 
\author{\IEEEauthorblockN{Scott Atchley\IEEEauthorrefmark{1}, 
David Dillow\IEEEauthorrefmark{1}, 
Galen Shipman\IEEEauthorrefmark{1}, 
Patrick Geoffray\IEEEauthorrefmark{2} and 
Jeffrey M.\ Squyres\IEEEauthorrefmark{3}}
\IEEEauthorblockA{\IEEEauthorrefmark{1}Oak Ridge National Laboratory, Oak Ridge, TN}
\IEEEauthorblockA{\IEEEauthorrefmark{2}Myricom, Inc., Arcadia, CA}
\IEEEauthorblockA{\IEEEauthorrefmark{3}Cisco Systems, Inc., San Jose, CA}}

% make the title area
\maketitle

\begin{abstract}
The abstract goes here.

\end{abstract}

% no keywords

% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle

\newcommand{\note}[1]{\colorbox{yellow!50}{Note: #1}}

\section{Introduction}
Introduction text goes here.

\section{Current State of the Art}
Over the years, many communication interfaces have come and gone. The few that have
remained and seen wide-spread adoption are BSD sockets\cite{bsd}, the Message Passing
Interface (MPI)\cite{mpi}, and some vendor-specific application programming interfaces
(API).

\subsection{Sockets} The socket interface is the most widely used by far. All major
operating systems provide support for sockets and the Internet and all the services it
provides would not exist without it. The popularity of sockets can be attributed to:

\begin{itemize}
\item Simple API
\item Robustness
\item Asynchronous operations
\end{itemize}

The API provides stream and datagram based modes, connection-oriented and connection-less
modes, and client/server semantics for connection-oriented modes. Based on the transport,
the API can supports multiple delivery modes (unicast, multicast, and/or broadcast). The
API does not provide for collective communication nor does it provide one-sided
operations.

Sockets implementations are mature and well understood. It does not assume or require
special hardware features (nor can it exploit them if they exist).

Both sends and receives are buffered allowing operations to complete quickly (if buffer
space is available for sends or data exists in the buffer for receives). Applications may
also choose to not block if need be. The downside of buffering is more work is required by
the CPU which can result in lower throughput over the network.

\subsection{MPI} In the high performance computing (HPC) arena, MPI is the dominant
interface for inter-process communication. Designed for maximum scalability, MPI has a
richer, but more complicated API.

It provides point-to-point (i.e. send-recv or two-sided semantics), collective, and
one-sided operations. For point-to-point communication, MPI provides a variety of modes
including blocking and non-blocking, synchronous and asynchronous, as well as \emph{ready}
mode (only send if a matching receive has been posted).

Multiple implementations exist\cite{ompi, mpich2, mvapich, ibm-mpi, intel-mpi, cray-mpi}
which support multiple operating systems and/or interconnects.  Rather than connections,
the API uses the notion of communication groups (i.e.  communicators) which include all
processes (MPI\_COMM\_WORLD) and may be split to include subsets of processes. MPI does
provide a notion of dynamic process management which includes MPI\_Comm\_accept and
MPI\_Comm\_connect, but this is less mature and much less used.

The MPI standard does not define an underlying network protocol and each MPI
implementation has written its own network abstraction layer (NAL). These NALs typically
support sockets as well as one or more vendor specific APIs.

MPI is a less mature interface compared to sockets. MPI is more fragile to use than
sockets. If an application using MPI encounters a communications fault, the application
typically aborts. Although work has been done on fault-tolerant MPI\cite{ft-mpi, mpi-ft},
that work has yet to be adopted by the broader HPC community.

The MPI standard does not specify buffering semantics (i.e. when to use eager versus
rendezvous mode). It has limited support for one-sided operations due to the lack of
memory registration.\note{Patrick, can you elaborate?}

\subsection{Vendor APIs} There are numberous vendor- and organization-specific APIs
including Infiniband's Verbs\cite{verbs}, Cray/Sandia's Portals\cite{portals}, Qlogic's
PSM\cite{psm}, Myricom's MX\cite{mx}, LBL's Gasnet\cite{gasnet}, and so on.  Overall, they
provide a lot of choice, but none is perfect (i.e. none have convinced they others to
adopt their API).  Since most are targeted to specific hardware, the APIs tend to be more
complicated.

Based on the ealier VIA specification\cite{via}, the Infiniband standard does not specify
an API; it only specifies which \emph{verbs} must be supported. After many vendors created
separate Verbs APIs, they eventually coalesced into the Open Fabric Association's (OFA)
Verbs. OFA's Verbs has had the broadest adoption, yet it still represents less than 50\%
of the machines on the Top 500\cite{top500} with some, but much less, adoption outside of
HPC.

Verbs has support for (small) two-sided and one-sided operations. All operations are
asynchronous. Verbs has support for reliable and unreliable modes, connection-oriented
and connection-less. Verbs does not support buffering; all receives must be posted before
sending. Also, all data movement operations require pinning the memory in advance. For
the most common reliable, connection-oriented communication, Verbs requires that the two
processes establish a queue-pair (QP), which is much more cumbersome than socket's
\texttt{connect()} and \texttt{accept()}.\note{can someone review this?}

The Portals API provides one-sided semantics (i.e.  Put/Get), uses match tags to steer
messages to the correct buffers. The API is connection-less and leaves it up to the NAL to
maintain any necessary connection state internally. Portals is mostly used an the largest
HPC systems such as ORNL's Jaguar\cite{jaguar} and Sandia's Red Sky\cite{red-sky}. The
Lustre distributed file system NAL, LNET, was orginally based on
Portals\cite{lnet}.

Both designed for implementing MPI, Myricom's MyrinetExpress (MX) and Qlogic's PathScale
Messages (PSM) have many similarities. Both provide a two-sided interface which uses
buffering for smaller messages and remote direct memory access for larger messages.  Both
are connection-less in that the target does not have to accept.  Both provide reliable,
in-order matching, but out-of-order completion.

\section{Goals for CCI}
Text goes here

\section{The CCI Interface}
Text goes here

\section{Evaluation}
Text goes here

\section{Conclusion}
The conclusion goes here.


% use section* for acknowledgement
\section*{Acknowledgment}

The authors would like to thank...


% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
\begin{thebibliography}{1}

\bibitem{IEEEhowto:kopka}
H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed.\hskip 1em plus
  0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

\end{thebibliography}

% that's all folks
\end{document}
